<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dos攻击</title>
      <link href="/2020/02/05/2020-02-05-%E4%BB%8EDos%E6%94%BB%E5%87%BB%E5%88%B0%E6%96%B0%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92/"/>
      <url>/2020/02/05/2020-02-05-%E4%BB%8EDos%E6%94%BB%E5%87%BB%E5%88%B0%E6%96%B0%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="Dos攻击"><a href="#Dos攻击" class="headerlink" title="Dos攻击"></a>Dos攻击</h1><p><strong>拒绝服务攻击</strong>（英语：denial-of-service attack，简称DoS攻击）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。DDoS攻击可以具体分成两种形式：<strong>带宽消耗型</strong>以及<strong>资源消耗型</strong>。它们都是透过大量合法或伪造的请求占用大量网络以及器材资源，以达到瘫痪网络以及系统的目的。</p><h2 id="宽带消耗型攻击"><a href="#宽带消耗型攻击" class="headerlink" title="宽带消耗型攻击"></a>宽带消耗型攻击</h2><p>DDoS宽带消耗攻击可以分为两个不同的层次：<strong>洪泛攻击</strong>或<strong>放大攻击</strong>。洪泛攻击的特点是利用僵尸程序发送大量流量至受损的受害者系统，目的在于堵塞其宽带。放大攻击与其类似，是通过恶意放大流量限制受害者系统的宽带；其特点是利用僵尸程序通过伪造的源IP(即攻击目标IP)向某些存在漏洞的服务器发送请求，服务器在处理请求后向伪造的源IP发送应答，由于这些服务的特殊性导致应答包比请求包更长，因此使用少量的宽带就能使服务器发送大量的应答到目标主机上。</p><ul><li><p><strong>UDP洪水攻击</strong>（User Datagram Protocol floods）</p><p>UDP（用户数据报协议）是一种无连接协议，当数据包通过UDP发送时，所有的数据包在发送和接收时不需要进行握手验证。当大量UDP数据包发送给受害系统时，可能会导致带宽饱和从而使得合法服务无法请求访问受害系统。遭受DDoS UDP洪泛攻击时，UDP数据包的目的端口可能是随机或指定的端口，受害系统将尝试处理接收到的数据包以确定本地运行的服务。如果没有应用程序在目标端口运行，受害系统将对源IP发出ICMP数据包，表明“目标端口不可达”。某些情况下，攻击者会伪造源IP地址以隐藏自己，这样从受害系统返回的数据包不会直接回到僵尸主机，而是被发送到被伪造地址的主机。有时UDP洪泛攻击也可能影响受害系统周围的网络连接，这可能导致受害系统附近的正常系统遇到问题。</p></li><li><p><strong>ICMP洪水攻击</strong>（ICMP floods）</p><p>ICMP（互联网控制消息协议）洪水攻击是通过向未良好设置的路由器发送广播信息占用系统资源的做法。</p></li><li><p><strong>死亡之Ping</strong>（ping of death）</p><p>死亡之Ping是产生超过IP协议能容忍的数据包数，若系统没有检查机制，就会死机。</p></li><li><p><strong>泪滴攻击</strong></p><p>每个数据要发送前，该数据包都会经过切割，每个小切割都会记录位移的信息，以便重组，但此攻击模式就是捏造位移信息，造成重组时发生问题，造成错误。</p></li></ul><h2 id="资源消耗型攻击"><a href="#资源消耗型攻击" class="headerlink" title="资源消耗型攻击"></a>资源消耗型攻击</h2><ul><li><p><strong>协议分析攻击</strong>（SYN flood，SYN洪水）</p><p>传送控制协议（TCP）同步（SYN）攻击。TCP进程通常包括发送者和接受者之间在数据包发送之前创建的完全信号交换。启动系统发送一个SYN请求，接收系统返回一个带有自己SYN请求的ACK（确认）作为交换。发送系统接着传回自己的ACK来授权两个系统间的通讯。若接收系统发送了SYN数据包，但没接收到ACK，接受者经过一段时间后会再次发送新的SYN数据包。接受系统中的处理器和内存资源将存储该TCP SYN的请求直至超时。DDoS TCP SYN攻击也被称为“资源耗尽攻击”，它利用TCP功能将僵尸程序伪装的TCP SYN请求发送给受害服务器，从而饱和服务处理器资源并阻止其有效地处理合法请求。它专门利用发送系统和接收系统间的三向信号交换来发送大量欺骗性的原IP地址TCP SYN数据包给受害系统。最终，大量TCP SYN攻击请求反复发送，导致受害系统内存和处理器资源耗尽，致使其无法处理任何合法用户的请求。</p></li><li><p><strong>LAND攻击</strong></p><p>这种攻击方式与SYN floods类似，不过在LAND攻击包中的原地址和目标地址都是攻击对象的IP。这种攻击会导致被攻击的机器死循环，最终耗尽资源而死机。</p></li><li><p><strong>CC攻击</strong>（Distributed HTTP flood，分布式HTTP洪水攻击）</p><p>CC攻击是DDoS攻击的一种类型，使用代理服务器向受害服务器发送大量貌似合法的请求（通常使用HTTP GET)。CC（Challenge Collapsar，挑战黑洞）根据其工具命名，攻击者创造性地使用代理机制，利用众多广泛可用的免费代理服务器发动DDoS攻击。许多免费代理服务器支持匿名模式，这使追踪变得非常困难。</p></li><li><p><strong>僵尸网络攻击</strong></p><p>僵尸网络是指大量被命令与控制（C&amp;C）服务器所控制的互联网主机群。攻击者传播恶意软件并组成自己的僵尸网络。僵尸网络难于检测的原因是，僵尸主机只有在执行特定指令时才会与服务器进行通讯，使得它们隐蔽且不易察觉。僵尸网络根据网络通讯协议的不同分为IRC、HTTP或P2P类等。</p></li><li><p><strong>应用程序级洪水攻击</strong>（Application level floods）</p><p>与前面叙说的攻击方式不同，应用程序级洪水攻击主要是针对应用软件层的，也就是高于OSI的。它同样是以大量消耗系统资源为目的，通过向IIS这样的网络服务程序提出无节制的资源申请来迫害正常的网络服务。</p><h2 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h2><p>故宫有四个门，游客只能从午门买票安检进入，从神武门和东华门出。在计算机中我们要借用这种策略，当通信流量进入/离开网络时要执行安全检查，做记录、丢弃或转发，这些工作由防火墙、入侵检测系统(IDS)和入侵防止系统(IPS)的运行设备完成。</p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>防火墙(firewall)是一个软硬件结合体，它将一个机构的内部网络和外部网络分隔开。Linux系统使用<strong>iptables</strong>命令产生一个防火墙，CentOS下可以使用<strong>firewall-cmd</strong>命令。防火墙可以分为三类：<strong>传统分组过滤器</strong>(traditional packet filter)，<strong>状态过滤器</strong>(stateful filter)和<strong>应用程序网关</strong>(application gateway)。</p><ul><li><p><strong>传统分组过滤器</strong>独立地检查每个数据报，然后基于管理员制定的规则决定数据报如何处理，通过还是丢弃。过略决定通常基于下列因素：</p><ul><li>IP源或目的地址</li><li>IP数据报中的协议类型字段：TCP、UDP、ICMP、OSPF等</li><li>TCP标志比特：SYN、ACK等</li><li>ICMP报文类型</li><li>数据报离开或进入网络的不同规则</li><li>对不同路由器接口的不同规则</li></ul><table><thead><tr><th align="center">动作</th><th align="center">源地址</th><th align="center">目的地址</th><th align="center">协议</th><th align="center">源端口</th><th align="center">目的端口</th><th align="center">标志比特</th></tr></thead><tbody><tr><td align="center">允许</td><td align="center">222.22/16</td><td align="center">222.22/16的外部</td><td align="center">TCP</td><td align="center">&gt;1023</td><td align="center">80</td><td align="center">任意</td></tr><tr><td align="center">允许</td><td align="center">222.22/16的外部</td><td align="center">222.22/16</td><td align="center">TCP</td><td align="center">80</td><td align="center">&gt;1023</td><td align="center">ACK</td></tr><tr><td align="center">允许</td><td align="center">222.22/16</td><td align="center">222.22/16的外部</td><td align="center">UDP</td><td align="center">&gt;1023</td><td align="center">53</td><td align="center">—</td></tr><tr><td align="center">允许</td><td align="center">222.22/16的外部</td><td align="center">222.22/16</td><td align="center">UDP</td><td align="center">53</td><td align="center">&gt;1023</td><td align="center">—</td></tr><tr><td align="center">允许</td><td align="center">全部</td><td align="center">全部</td><td align="center">全部</td><td align="center">全部</td><td align="center">全部</td><td align="center">全部</td></tr></tbody></table><pre><code>表 1</code></pre><p>表1显示了某机构222.22/16的访问控制列表的例子。前两条规则一起允许内部用户在Web上冲浪：第一条规则允许任何目的端口为80的TCP分组离开该机构网络，第二条规则允许任何源端口为80且ACK比特置位的TCP分组进入该机构网络，注意如果有外部主机试图与一台内部主机建立TCP连接，该连接将会被阻挡(建立连接时SYN字段置位，ACK字段不置位)；接下来的两条规则允许DNS流量进入和离开该机构网络。这张表限制除Web和DNS流量外的所有流量。</p></li><li><p>重新看一下表1，它是允许任何来自外部ACK=1且源端口为80的TCP分组通过的，试想一下，这样的分组是能够被用来异常分组来攻击网络的，<strong>状态过滤器</strong>通过维护一张连接表来解决问题，过滤器通过对比连接表和限制表来确保安全，例如一个连接60秒没有任何活动，过滤器就假设该连接结束了。</p></li><li><p><strong>应用程序网关</strong></p></li></ul><h3 id="入侵检测系统"><a href="#入侵检测系统" class="headerlink" title="入侵检测系统"></a>入侵检测系统</h3><p>分组过滤器检查IP、TCP、UDP和ICMP首部字段。然而，为了检测多种攻击类型，我们需要执行<strong>深度分组检查</strong>(deep packet inspection)，即检查首部以外的数据部分。这就需要两种设备，一种是<strong>入侵检测系统</strong>(Intrusion Detection System，IDS)，负责观察潜在恶意流量产生告警；一种是<strong>入侵防止系统</strong>(Intrusion Prevention System，IPS)，这两种系统统称为<strong>IDS系统</strong>。<strong>IDS系统</strong>大致分为<strong>基于特征的系统</strong>(signature-based system)和<strong>基于异常的系统</strong>(anomaly-based system)。</p><ul><li><p><strong>基于特征</strong>的IDS维护了一个攻击特性数据库，IDS运行流程如下：</p><ol><li>嗅探每个通过它的数据组</li><li>将分组与数据库中的特征进行比较</li><li>倘若特征匹配，IDS产生告警，发送Email给管理员或做成日志</li></ol><p>基于特征的IDS的缺陷：</p><ol><li>IDS基于过往的攻击特征做比对，缺乏对新攻击的判断力</li><li>即使与一个特征匹配，也可能不是一个攻击，因此产生了虚假告警</li><li>为了解决第二个缺陷，分组必须与一个特征集合做对比，IDS可能处于一种过载状态并因此难以检测出许多恶意分组</li></ol></li><li><p><strong>基于异常</strong>的IDS观察正常运行的流量时，会产生一个流量概况文件，然后它寻找统计上不寻常的分组流，例如ICMP分组不寻常的百分比，端口扫描或Ping掠过导致指数性突然增长。基于异常的IDS的最大特点是不依赖现有攻击的知识，另一方面，区分正常流量和异常流量是一个挑战，不过机器学习的发展肯定有了一定的成果，之后查资料再做补充。</p></li></ul><h4 id="Snort"><a href="#Snort" class="headerlink" title="Snort"></a>Snort</h4><p><strong>Snort</strong>是一个开放源码的IDS，能够运行在Linux、Unix和Windows系统上，使用了通用的嗅探接口<strong>libpcap</strong>，<strong>Wireshark</strong>。来看一个Snort的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert icmp $EXTERNAL_NET any -&gt;$HOME_NET any</span><br><span class="line">(msg:"ICMP PING NMAP"; dsize: 0; itype: 8;)</span><br></pre></td></tr></table></figure><p>这个特征由外部网络($EXTERNAL_NET)进入内部网络($HOME_NET)的任何ICMP分组所匹配，其类型是8(ICMP ping)并具有空负载(dsize=0)。因为nmap用这些特定的特征产生这些ping分组，所以设计出该特征来检测nmap的ping扫描，当某分组匹配到这些特征时，Snort产生一个“ICMP PING NMAP”的警告。</p></li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><h1 id="武汉加油！"><a href="#武汉加油！" class="headerlink" title="武汉加油！"></a>武汉加油！</h1>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Dos攻击 </tag>
            
            <tag> 中国加油 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于数据库的一些技巧</title>
      <link href="/2019/11/21/2019-11-21-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/11/21/2019-11-21-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h3 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h3><ul><li>IN操作符一般比一组OR操作符执行的更快，查的是IN会解析为排序树。</li><li>在简单的WHERE子句中，使用NOT确实没有什么优势。但在更为复杂的的子句中NOT非常有用。例如，在与IN操作符联合使用时，NOT可以非常简单的找出与条件列表匹配的行。</li><li>等值连接（equaljoin）==内连接（innerjoin）</li></ul><h3 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h3><ul><li>如果想从表中删除所有行，不要用DELETE。可以使用TURNCATE TABLE，它完成相同的工作，但速度更快（因为不记录数据的变动）</li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul><li>一个常见的视图应用是隐藏复杂SQL</li><li>视图是虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装SELECT语句的层次，可用来简化数据处理，重新格式化或保护基础数据。</li></ul><h3 id="高级SQL特性"><a href="#高级SQL特性" class="headerlink" title="高级SQL特性"></a>高级SQL特性</h3><ul><li>索引改善了检索操作的性能，但降低了数据插入、修改和删除的性能。所以建立数据库的读写分离？</li><li>索引的效率随表数据的增加或改变而变化。许多数据库管理员发现，过去创建的某个理想的索引经过几个月的数据处理后可能变得不再理想了。最好定期检查索引，并根据需要对索引进行调整。</li><li>一般来说，约束的处理比触发器快，因此在可能的时候，应该尽量使用约束。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序算法</title>
      <link href="/2019/11/21/2019-11-21-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/11/21/2019-11-21-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li><p>稳定排序</p></li><li><p>O(n^2)</p></li><li><p>算法运作</p><ol><li>比较相邻的两个元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的动作，从开始第一对到结尾最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上述步骤，直到没有任何一对数字需要比较。</li></ol></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_LEN 255</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> elemType int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, temp;</span><br><span class="line">Boolean exchanged = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; exchanged &amp;&amp; i &lt; len<span class="number">-1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line">exchanged = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                exchanged = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li><p>稳定排序</p></li><li><p>O(n^2)</p></li><li><p>算法运作</p><ol><li>从第一个元素开始，认为它已经排序。</li><li>取出下一个元素，在一个已经排序的元素中从后往前扫描。</li><li>如果该元素（已排序）大于新元素，将该元素移动到下一个位置。</li><li>重复步骤3，找到已排序的元素小于或等于新元素的位置。</li><li>将新元素插入到该位置后。</li><li>重复步骤2~5。</li></ol></li><li><p>如果比较操作的代价比交换操作大，可以采用二分查找来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。</p></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, key;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        key = arr[i];</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li><p>不稳定排序</p></li><li><p>O(n^2)</p></li><li><p>算法运作</p><ol><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。</li><li>重复步骤2。</li></ol></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[<span class="built_in">min</span>]) &#123;</span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[<span class="built_in">min</span>];</span><br><span class="line">        arr[<span class="built_in">min</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul><li><p>不稳定排序</p></li><li><p>O(n^2)</p></li><li><p>算法运作</p><ul><li>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</li><li>希尔排序的关键部分是选择步长。</li></ul></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap, i, j;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; tmp; j -= gap)</span><br><span class="line">                arr[j+gap] = arr[j];</span><br><span class="line">            arr[j+gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><p>稳定排序</p></li><li><p>O(nlogn)</p></li><li><p>算法运作</p><ul><li><p>分治法</p><ul><li>分割：递归的把当前序列平均分成两半。</li><li>归并：在保持元素顺序的同时将上一步得到的子序列集成到一起。</li></ul></li><li><p>归并</p><ul><li><p>递归法（Top-down）</p><ol><li>申请空间，使其大小为两个已排序序列之和，该空间用来存放合并后的序列。</li><li>设定两个指针，初始位置分别为两个已排序序列的起始位置。</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并将指针移动到下一个位置。</li><li>重复步骤3直到某一指针到达序列尾。</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol></li><li><p>迭代法（Bottom-up）</p><ol><li>将序列每相邻两个数字进行归并操作，形成ceil（n/2）个序列，排序后每个序列包含两/一个元素。</li><li>若此时序列数不是1个则将上述序列再次归并，形成ceil（n/4）个序列，每个序列包含四/三个元素。</li><li>重复步骤2，直到所有元素排序完毕，即序列数为1。</li></ol></li></ul></li></ul></li><li><p>代码实现</p><ul><li><p>递归</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> reg[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= <span class="built_in">end</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">end</span> - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">    <span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line">    <span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = <span class="built_in">end</span>;</span><br><span class="line">    merge_sort_recursive(arr, reg, start1, end1);</span><br><span class="line">    merge_sort_recursive(arr, reg, start2, end2);</span><br><span class="line">    <span class="keyword">int</span> k = start;</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start] &lt; arr[start2] ? arr[start1++] : arr[start2];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">        reg[k++] = arr[start1];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start2];</span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= <span class="built_in">end</span>; k++)</span><br><span class="line">        arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reg[len];</span><br><span class="line">    merge_sort_recursive(arr, reg, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = arr;</span><br><span class="line">    <span class="keyword">int</span> *b = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> seg, start;</span><br><span class="line">    <span class="keyword">for</span> (seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (start = <span class="number">0</span>; start &lt; len; start += seg * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = start, mid = <span class="built_in">min</span>(start + seg, len), high = <span class="built_in">min</span>(start + seg * <span class="number">2</span>, len);</span><br><span class="line">            <span class="keyword">int</span> k = low;</span><br><span class="line">            <span class="keyword">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="keyword">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &gt; a[start2] ? a[start++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> *temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li><p>不稳定排序</p></li><li><p>O(nlogn)</p></li><li><p>算法运作</p><ol><li>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点。</li><li>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序。</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算。</li></ol></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dad = start;</span><br><span class="line">    <span class="keyword">int</span> son = start * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt; <span class="built_in">end</span> &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>])</span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(&amp;arr[dad], &amp;arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = son * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = len / <span class="number">2</span> <span class="number">-1</span>; i&gt;= <span class="number">0</span>; i--)</span><br><span class="line">        max_heapify(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>], &amp;arr[len - <span class="number">1</span>]);</span><br><span class="line">        max_heapify(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li><p>不稳定排序</p></li><li><p>O(nlogn)</p></li><li><p>算法运作</p><p>   再次利用分治法，把一个序列分为两个子序列，再递归的排序两个子序列。</p><ol><li>挑选基准值：从数列中挑选一个元素，称为基准（pivot）。</li><li>分割：重新排序数列，所有比基准值小的元素放在基准前面，比基准大的放在基准后面（与基准相等的随便放到任意一边）。</li><li>递归排序子序列：递归的将小于基准的子序列和大于基准的子序列排序。</li></ol></li><li><p>代码实现</p><ul><li><p>递归法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; <span class="built_in">end</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = arr[<span class="built_in">end</span>];</span><br><span class="line">    <span class="keyword">int</span> left = start, right = <span class="built_in">end</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">            right--;</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[<span class="built_in">end</span>])</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[<span class="built_in">end</span>]);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        left++;</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[<span class="built_in">end</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left)</span><br><span class="line">        quick_sort_recursive(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, left, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Range</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, <span class="built_in">end</span>;</span><br><span class="line">&#125;   Range;</span><br><span class="line"></span><br><span class="line"><span class="function">Range <span class="title">new_Range</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    Range r;</span><br><span class="line">    r.start = s;</span><br><span class="line">    r.<span class="built_in">end</span> = e;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = <span class="keyword">new</span> Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.<span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = arr[(range.start + range.<span class="built_in">end</span>) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = range.start, right = range.<span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid) ++left;</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt;= mid) --right;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                swap(&amp;arr[left], arr[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; right) r[p++] = new_Range(range.start, right);</span><br><span class="line">        <span class="keyword">if</span> (range.<span class="built_in">end</span> &gt; left) r[p++] = new_Range(left, range.<span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科-排序算法</a></p></blockquote><blockquote><p><a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">算法可视化</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
